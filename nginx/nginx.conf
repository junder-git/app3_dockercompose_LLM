# Minimal working nginx.conf - Manual admin creation
user nobody;
worker_processes auto;
error_log /var/log/nginx/error.log warn;
pid /var/run/nginx.pid;

events {
    worker_connections 1024;
    use epoll;
}

http {
    include /usr/local/openresty/nginx/conf/mime.types;
    default_type application/octet-stream;

    # Just store admin credentials in init_by_lua_block
    init_by_lua_block {
        local admin_username = os.getenv("ADMIN_USERNAME") or "admin1"
        local admin_password = os.getenv("ADMIN_PASSWORD") or "admin1"
        local admin_user_id = os.getenv("ADMIN_USER_ID") or "admin"
        
        ngx.shared.config:set("admin_username", admin_username)
        ngx.shared.config:set("admin_password", admin_password)
        ngx.shared.config:set("admin_user_id", admin_user_id)
        ngx.shared.config:set("admin_created", "false")  -- Track if admin is created
        
        ngx.log(ngx.ERR, "INIT: Admin credentials loaded - " .. admin_username)
    }

    # Shared memory zones
    lua_shared_dict config 1m;

    # Upstreams
    upstream redis_backend {
        server devstral-redis:6379;
        keepalive 10;
    }

    upstream ollama_backend {
        server devstral-ollama:11434;
        keepalive 8;
    }

    # Redis connection settings
    redis2_connect_timeout 1s;
    redis2_send_timeout 1s;
    redis2_read_timeout 1s;

    server {
        listen 80;
        server_name localhost;

        root /usr/local/openresty/nginx/html;
        index index.html;

        # Removed /create-admin endpoint - using auto-creation instead

        # Internal Redis operations
        location ~ ^/redis-internal/hgetall/(.+) {
            internal;
            redis2_query hgetall $1;
            redis2_pass redis_backend;
        }

        location ~ ^/redis-internal/exists/(.+) {
            internal;
            redis2_query exists $1;
            redis2_pass redis_backend;
        }

        location ~ ^/redis-internal/hmset/(.+) {
            internal;
            set_by_lua_block $redis_cmd {
                local key_and_args = ngx.var[1]
                local parts = {}
                for part in key_and_args:gmatch("[^/]+") do
                    table.insert(parts, part)
                end
                
                local cmd = "hmset"
                for i, part in ipairs(parts) do
                    cmd = cmd .. " " .. part
                end
                return cmd
            }
            redis2_raw_query $redis_cmd;
            redis2_pass redis_backend;
        }

        # Generic redis2 fallback
        location ~ ^/redis-internal/(.+) {
            internal;
            redis2_raw_query $1;
            redis2_pass redis_backend;
        }

        # ===== AUTH ENDPOINTS =====
        
        location = /api/auth/login {
            access_by_lua_block {
                -- Auto-create admin user on first login attempt
                local admin_created = ngx.shared.config:get("admin_created")
                if admin_created == "false" then
                    local redis = require "resty.redis"
                    local admin_username = ngx.shared.config:get("admin_username")
                    local admin_password = ngx.shared.config:get("admin_password")
                    local admin_user_id = ngx.shared.config:get("admin_user_id")
                    
                    ngx.log(ngx.ERR, "AUTO-CREATE: Checking if admin user needs to be created...")
                    
                    local red = redis:new()
                    local ok, err = red:connect("devstral-redis", 6379)
                    if ok then
                        local exists = red:exists("user:" .. admin_username)
                        if exists == 0 then
                            ngx.log(ngx.ERR, "AUTO-CREATE: Creating admin user...")
                            local timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ")
                            local result = red:hmset("user:" .. admin_username,
                                "id", admin_user_id,
                                "username", admin_username,
                                "password_hash", admin_password,
                                "is_admin", "true",
                                "is_approved", "true",
                                "created_at", timestamp
                            )
                            if result then
                                ngx.log(ngx.ERR, "AUTO-CREATE: ✅ Admin user created successfully!")
                                ngx.shared.config:set("admin_created", "true")
                            else
                                ngx.log(ngx.ERR, "AUTO-CREATE: ❌ Failed to create admin user")
                            end
                        else
                            ngx.log(ngx.ERR, "AUTO-CREATE: Admin user already exists")
                            ngx.shared.config:set("admin_created", "true")
                        end
                        red:close()
                    else
                        ngx.log(ngx.ERR, "AUTO-CREATE: Failed to connect to Redis: " .. (err or "unknown"))
                    end
                end
            }
            content_by_lua_file /usr/local/openresty/nginx/lua/auth.lua;
        }

        location = /api/auth/register {
            content_by_lua_file /usr/local/openresty/nginx/lua/auth.lua;
        }

        location = /api/auth/verify {
            content_by_lua_file /usr/local/openresty/nginx/lua/auth.lua;
        }

        location = /health {
            content_by_lua_block {
                ngx.say('{"status": "healthy", "timestamp": "' .. ngx.utctime() .. '"}')
            }
        }

        # Static HTML routes
        location = / { try_files /index.html =404; }
        location = /login { try_files /login.html =404; }
        location = /register { try_files /register.html =404; }
        location = /chat { try_files /chat.html =404; }
        location = /admin { try_files /admin.html =404; }

        # Static files
        location / {
            try_files $uri $uri/ =404;
        }

        # Error pages
        error_page 404 /404.html;
        error_page 500 502 503 504 /50x.html;
    }
}