# Fixed nginx.conf - Rate limiting fix for login issues
user nobody;
worker_processes auto;
error_log /var/log/nginx/error.log warn;
pid /var/run/nginx.pid;

events {
    worker_connections 1024;
    use epoll;
}

http {
    include /usr/local/openresty/nginx/conf/mime.types;
    default_type application/octet-stream;

    # Enhanced logging
    log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                    '$status $body_bytes_sent "$http_referer" '
                    '"$http_user_agent" "$http_x_forwarded_for"';
    
    access_log /var/log/nginx/access.log main;

    # Security headers
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header Referrer-Policy "strict-origin-when-cross-origin" always;

    # Performance optimizations
    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout 65;
    types_hash_max_size 2048;

    # Gzip compression
    gzip on;
    gzip_vary on;
    gzip_min_length 1024;
    gzip_types text/plain text/css text/xml text/javascript application/javascript application/json;

    # Upstreams
    upstream redis_backend {
        server devstral-redis:6379;
        keepalive 10;
    }

    upstream ollama_backend {
        server devstral-ollama:11434;
        keepalive 8;
    }

    # Redis connection settings
    redis2_connect_timeout 5s;
    redis2_send_timeout 10s;
    redis2_read_timeout 10s;

    # FIXED: More generous rate limiting zones
    limit_req_zone $binary_remote_addr zone=api:10m rate=60r/m;      # Increased from 30r/m
    limit_req_zone $binary_remote_addr zone=auth:10m rate=20r/m;     # Increased from 5r/m
    limit_req_zone $binary_remote_addr zone=chat:10m rate=30r/m;     # New zone for chat

    server {
        listen 80;
        server_name localhost;

        root /usr/local/openresty/nginx/html;
        index index.html;

        # Hide nginx version
        server_tokens off;

        # Enhanced client settings
        client_max_body_size 10M;
        client_body_timeout 60s;
        client_header_timeout 60s;
        send_timeout 60s;

        # ===== INTERNAL REDIS OPERATIONS =====
        
        location ~ ^/redis-internal/hgetall/(.+) {
            internal;
            redis2_query hgetall $1;
            redis2_pass redis_backend;
            redis2_literal_raw_query on;
        }

        location ~ ^/redis-internal/hget/(.+) {
            internal;
            set_by_lua_block $redis_cmd {
                local key_and_field = ngx.var[1]
                local parts = {}
                for part in key_and_field:gmatch("[^/]+") do
                    table.insert(parts, part)
                end
                return "hget " .. parts[1] .. " " .. parts[2]
            }
            redis2_raw_query $redis_cmd;
            redis2_pass redis_backend;
        }

        location ~ ^/redis-internal/exists/(.+) {
            internal;
            redis2_query exists $1;
            redis2_pass redis_backend;
        }

        location ~ ^/redis-internal/del/(.+) {
            internal;
            redis2_query del $1;
            redis2_pass redis_backend;
        }

        location ~ ^/redis-internal/keys/(.+) {
            internal;
            redis2_query keys $1;
            redis2_pass redis_backend;
        }

        location ~ ^/redis-internal/sadd/(.+) {
            internal;
            set_by_lua_block $redis_cmd {
                local key_and_member = ngx.var[1]
                local parts = {}
                for part in key_and_member:gmatch("[^/]+") do
                    table.insert(parts, part)
                end
                return "sadd " .. parts[1] .. " " .. parts[2]
            }
            redis2_raw_query $redis_cmd;
            redis2_pass redis_backend;
        }

        location ~ ^/redis-internal/srem/(.+) {
            internal;
            set_by_lua_block $redis_cmd {
                local key_and_member = ngx.var[1]
                local parts = {}
                for part in key_and_member:gmatch("[^/]+") do
                    table.insert(parts, part)
                end
                return "srem " .. parts[1] .. " " .. parts[2]
            }
            redis2_raw_query $redis_cmd;
            redis2_pass redis_backend;
        }

        location ~ ^/redis-internal/smembers/(.+) {
            internal;
            redis2_query smembers $1;
            redis2_pass redis_backend;
        }

        location ~ ^/redis-internal/hset/(.+) {
            internal;
            set_by_lua_block $redis_cmd {
                local key_and_args = ngx.var[1]
                local parts = {}
                for part in key_and_args:gmatch("[^/]+") do
                    table.insert(parts, part)
                end
                
                local cmd = "hset"
                for i, part in ipairs(parts) do
                    cmd = cmd .. " " .. part
                end
                return cmd
            }
            redis2_raw_query $redis_cmd;
            redis2_pass redis_backend;
        }

        location ~ ^/redis-internal/hmset/(.+) {
            internal;
            set_by_lua_block $redis_cmd {
                local key_and_args = ngx.var[1]
                local parts = {}
                for part in key_and_args:gmatch("[^/]+") do
                    table.insert(parts, part)
                end
                
                local cmd = "hmset"
                for i, part in ipairs(parts) do
                    cmd = cmd .. " " .. part
                end
                return cmd
            }
            redis2_raw_query $redis_cmd;
            redis2_pass redis_backend;
        }

        location ~ ^/redis-internal/ping {
            internal;
            redis2_query ping;
            redis2_pass redis_backend;
        }

        # ===== INTERNAL OLLAMA PROXY =====
        
        location = /proxy-ollama-tags {
            internal;
            proxy_pass http://ollama_backend/api/tags;
            proxy_method GET;
            proxy_set_header Host $host;
            proxy_connect_timeout 5s;
            proxy_read_timeout 5s;
            proxy_send_timeout 5s;
        }

        # ===== AUTH ENDPOINTS =====
        
        location ~ ^/api/auth/(.+) {
            content_by_lua_file /usr/local/openresty/nginx/lua/auth.lua;
            # FIXED: More generous rate limiting for auth
            limit_req zone=auth burst=10 nodelay;
            limit_req_status 429;
        }

        # ===== CHAT ENDPOINTS =====
        
        # Chat persistence endpoints (handled by Lua)
        location ~ ^/api/chat/(save|load|current|clear|test) {
            content_by_lua_file /usr/local/openresty/nginx/lua/chat.lua;
            # FIXED: Use separate chat zone with generous limits
            limit_req zone=chat burst=15 nodelay;
            limit_req_status 429;
        }

        # Main chat endpoint (proxied to Ollama)
        location = /api/chat {
            # Handle OPTIONS for CORS
            if ($request_method = 'OPTIONS') {
                add_header Access-Control-Allow-Origin *;
                add_header Access-Control-Allow-Methods "GET, POST, OPTIONS";
                add_header Access-Control-Allow-Headers "Origin, X-Requested-With, Content-Type, Accept, Authorization";
                add_header Access-Control-Max-Age 1728000;
                add_header Content-Type "text/plain; charset=utf-8";
                add_header Content-Length 0;
                return 204;
            }

            # Auth check using Lua
            access_by_lua_file /usr/local/openresty/nginx/lua/chat.lua;
            
            # Proxy to Ollama with enhanced settings
            proxy_pass http://ollama_backend/api/chat;
            proxy_http_version 1.1;
            proxy_set_header Connection "";
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header Accept-Encoding "";
            
            proxy_pass_request_headers on;
            proxy_pass_request_body on;
            
            # Enhanced timeout settings for hybrid mode
            proxy_buffering off;
            proxy_cache off;
            proxy_read_timeout 600s;
            proxy_send_timeout 600s;
            proxy_connect_timeout 30s;
            
            # Error handling
            proxy_intercept_errors off;
            proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504;
            proxy_next_upstream_timeout 60s;
            proxy_next_upstream_tries 3;
            
            # CORS headers
            add_header Access-Control-Allow-Origin *;
            add_header Access-Control-Allow-Methods "GET, POST, OPTIONS";
            add_header Access-Control-Allow-Headers "Origin, X-Requested-With, Content-Type, Accept, Authorization";
            
            # FIXED: More generous rate limiting for chat
            limit_req zone=chat burst=5 nodelay;
            limit_req_status 429;
        }

        # ===== ADMIN ENDPOINTS =====
        
        location ~ ^/api/admin/(.+) {
            content_by_lua_file /usr/local/openresty/nginx/lua/admin.lua;
            # FIXED: More generous rate limiting for admin
            limit_req zone=api burst=10 nodelay;
            limit_req_status 429;
        }

        # ===== SECURE HTML ROUTES =====
        
        location = /chat {
            access_by_lua_block {
                local token = ngx.var.arg_token or ngx.var.cookie_auth_token
                local auth_header = ngx.var.http_authorization
                
                if auth_header and string.match(auth_header, "^Bearer ") then
                    token = string.sub(auth_header, 8)
                end
                
                if not token then
                    ngx.log(ngx.INFO, "No token found for /chat, serving page for client-side redirect")
                end
            }
            
            try_files /chat.html =404;
        }

        location = /admin {
            access_by_lua_block {
                local cjson = require "cjson"
                
                local token = ngx.var.arg_token or ngx.var.cookie_auth_token
                local auth_header = ngx.var.http_authorization
                
                if auth_header and string.match(auth_header, "^Bearer ") then
                    token = string.sub(auth_header, 8)
                end
                
                if not token then
                    ngx.log(ngx.WARN, "Admin access attempted without token from " .. ngx.var.remote_addr)
                    return ngx.redirect("/login")
                end
                
                local ok, payload = pcall(function()
                    return cjson.decode(ngx.decode_base64(token))
                end)
                
                if not ok or not payload.exp or payload.exp < ngx.time() then
                    ngx.log(ngx.WARN, "Admin access with invalid token from " .. ngx.var.remote_addr)
                    return ngx.redirect("/login")
                end
                
                if not payload.is_admin then
                    ngx.log(ngx.WARN, "Non-admin user attempted admin access: " .. (payload.username or "unknown"))
                    return ngx.redirect("/unauthorised")
                end
                
                ngx.log(ngx.INFO, "Admin access granted to: " .. payload.username)
            }
            
            try_files /admin.html =404;
        }

        # ===== PUBLIC ROUTES =====
        
        location = / { 
            try_files /index.html =404; 
        }
        
        location = /login { 
            try_files /login.html =404; 
        }
        
        location = /register { 
            try_files /register.html =404; 
        }

        location = /unauthorised { 
            try_files /unauthorised.html =404; 
        }

        # ===== HEALTH CHECK =====
        
        location = /health {
            access_log off;
            content_by_lua_block {
                -- Check Redis
                local redis_ok = false
                local redis_res = ngx.location.capture("/redis-internal/ping")
                if redis_res.status == 200 and redis_res.body:match("PONG") then
                    redis_ok = true
                end
                
                -- Check Ollama
                local ollama_ok = false
                local ollama_res = ngx.location.capture("/proxy-ollama-tags")
                if ollama_res.status == 200 then
                    ollama_ok = true
                end
                
                local status = "healthy"
                if not redis_ok or not ollama_ok then
                    status = "degraded"
                end
                
                ngx.header.content_type = "application/json"
                ngx.say('{"status": "' .. status .. '", "timestamp": "' .. ngx.utctime() .. '", "redis": ' .. (redis_ok and "true" or "false") .. ', "ollama": ' .. (ollama_ok and "true" or "false") .. '}')
            }
        }

        # ===== STATIC FILES =====
        
        location ~* \.(css|js|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$ {
            expires 1h;
            add_header Cache-Control "public, immutable";
            try_files $uri =404;
        }

        # Add favicon.ico handling
        location = /favicon.ico {
            access_log off;
            log_not_found off;
            return 204;
        }

        # ===== SECURITY BLOCKS =====
        
        location ~ /\. {
            deny all;
            access_log off;
            log_not_found off;
        }

        location ~* \.(conf|log|sql|sh|py|bak|old|tmp)$ {
            deny all;
            access_log off;
            log_not_found off;
        }

        # Default location
        location / {
            try_files $uri $uri/ =404;
        }

        # ===== ERROR PAGES =====
        
        error_page 404 /404.html;
        error_page 403 /unauthorised.html;
        error_page 429 /rate_limit.html;
        error_page 500 502 503 504 /50x.html;
    }
}