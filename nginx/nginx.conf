# OpenResty compatible nginx.conf
# OpenResty has redis2 and lua built-in, no external modules needed

user nobody;
worker_processes auto;
error_log /var/log/nginx/error.log warn;
pid /var/run/nginx.pid;

events {
    worker_connections 1024;
    use epoll;
}

http {
    include /etc/nginx/mime.types;
    default_type application/octet-stream;

    # OpenResty has lua built-in, no need for NJS imports
    # We'll use lua for server-side logic

    # Upstreams
    upstream redis_backend {
        server redis:6379;
        keepalive 10;
    }

    upstream ollama_backend {
        server ollama:11434;
        keepalive 8;
    }

    # Redis connection settings
    redis2_connect_timeout 1s;
    redis2_send_timeout 1s;
    redis2_read_timeout 1s;

    server {
        listen 80;
        server_name localhost;

        root /usr/local/openresty/nginx/html;
        index index.html;
        
        # ===== REDIS2 DIRECT ACCESS =====
        
        # Set Redis key-value
        # POST /redis/set with JSON: {"key": "mykey", "value": "myvalue"}
        location = /redis/set {
            access_by_lua_block {
                local auth_header = ngx.var.http_authorization
                if not auth_header then
                    ngx.status = 401
                    ngx.say('{"error": "Authorization required"}')
                    ngx.exit(401)
                end
                -- Allow internal requests
                if auth_header == "Bearer internal" then
                    return
                end
                -- Add proper auth validation here for external requests
            }
            
            content_by_lua_block {
                local cjson = require "cjson"
                ngx.req.read_body()
                local body = ngx.req.get_body_data()
                
                if not body then
                    ngx.status = 400
                    ngx.say('{"error": "Request body required"}')
                    return
                end
                
                local data = cjson.decode(body)
                if not data.key or not data.value then
                    ngx.status = 400
                    ngx.say('{"error": "Key and value required"}')
                    return
                end
                
                -- Set variables for redis2
                ngx.var.redis_key = data.key
                ngx.var.redis_value = data.value
                
                -- Execute redis command
                local res = ngx.location.capture("/redis-internal/set")
                if res.status == 200 then
                    ngx.say('{"success": true, "result": "' .. res.body:gsub('[\r\n]', '') .. '"}')
                else
                    ngx.status = 500
                    ngx.say('{"error": "Redis operation failed"}')
                end
            }
        }
        
        # Get Redis key value
        # GET /redis/get?key=mykey
        location = /redis/get {
            access_by_lua_block {
                local auth_header = ngx.var.http_authorization
                if not auth_header then
                    ngx.status = 401
                    ngx.say('{"error": "Authorization required"}')
                    ngx.exit(401)
                end
                -- Allow internal requests
                if auth_header == "Bearer internal" then
                    return
                end
            }
            
            content_by_lua_block {
                local key = ngx.var.arg_key
                if not key or key == '' then
                    ngx.status = 400
                    ngx.say('{"error": "Key parameter required"}')
                    return
                end
                
                -- Use redis2 module
                local res = ngx.location.capture("/redis-internal/get/" .. key)
                if res.status == 200 then
                    local body = res.body:gsub('[\r\n]', '')
                    if body == '$-1' or body == '' then
                        ngx.say('{"success": true, "value": null}')
                    else
                        ngx.say('{"success": true, "value": "' .. body .. '"}')
                    end
                else
                    ngx.status = 500
                    ngx.say('{"error": "Redis operation failed"}')
                end
            }
        }
        
        # Get all hash fields
        # GET /redis/hgetall?key=user:123
        location = /redis/hgetall {
            access_by_lua_block {
                local auth_header = ngx.var.http_authorization
                if not auth_header then
                    ngx.status = 401
                    ngx.say('{"error": "Authorization required"}')
                    ngx.exit(401)
                end
                -- Allow internal requests
                if auth_header == "Bearer internal" then
                    return
                end
            }
            
            content_by_lua_block {
                local cjson = require "cjson"
                local key = ngx.var.arg_key
                if not key or key == '' then
                    ngx.status = 400
                    ngx.say('{"error": "Key parameter required"}')
                    return
                end
                
                local res = ngx.location.capture("/redis-internal/hgetall/" .. key)
                if res.status == 200 then
                    local body = res.body
                    local lines = {}
                    for line in body:gmatch("[^\r\n]+") do
                        table.insert(lines, line)
                    end
                    
                    local result = {}
                    for i = 1, #lines, 2 do
                        if lines[i+1] then
                            result[lines[i]] = lines[i+1]
                        end
                    end
                    
                    ngx.say(cjson.encode({success = true, data = result}))
                else
                    ngx.status = 500
                    ngx.say('{"error": "Redis operation failed"}')
                end
            }
        }
        
        # Set hash field
        # POST /redis/hset with JSON: {"key": "user:123", "field": "name", "value": "john"}
        location = /redis/hset {
            access_by_lua_block {
                local auth_header = ngx.var.http_authorization
                if not auth_header then
                    ngx.status = 401
                    ngx.say('{"error": "Authorization required"}')
                    ngx.exit(401)
                end
                -- Allow internal requests
                if auth_header == "Bearer internal" then
                    return
                end
            }
            
            content_by_lua_block {
                local cjson = require "cjson"
                ngx.req.read_body()
                local body = ngx.req.get_body_data()
                
                if not body then
                    ngx.status = 400
                    ngx.say('{"error": "Request body required"}')
                    return
                end
                
                local data = cjson.decode(body)
                if not data.key or not data.field or not data.value then
                    ngx.status = 400
                    ngx.say('{"error": "Key, field and value required"}')
                    return
                end
                
                ngx.var.redis_key = data.key
                ngx.var.redis_field = data.field  
                ngx.var.redis_value = data.value
                
                local res = ngx.location.capture("/redis-internal/hset")
                if res.status == 200 then
                    ngx.say('{"success": true, "result": "' .. res.body:gsub('[\r\n]', '') .. '"}')
                else
                    ngx.status = 500
                    ngx.say('{"error": "Redis operation failed"}')
                end
            }
        }
        
        # Internal Redis operations
        location ~ ^/redis-internal/(.+) {
            internal;
            redis2_query $1;
            redis2_pass redis_backend;
        }

        # ===== OLLAMA WEBSOCKET PROXY =====
        
        # WebSocket proxy for Ollama streaming
        location /ollama/api/chat {
            access_by_lua_block {
                local auth_header = ngx.var.http_authorization
                if not auth_header then
                    ngx.status = 401
                    ngx.say('{"error": "Authorization required"}')
                    ngx.exit(401)
                end
            }
            
            proxy_pass http://ollama_backend/api/chat;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # WebSocket specific settings
            proxy_buffering off;
            proxy_read_timeout 300s;
            proxy_connect_timeout 75s;
            
            # Handle streaming responses
            proxy_cache off;
            proxy_set_header Cache-Control no-cache;
        }
        
        # Regular HTTP proxy for Ollama non-streaming requests
        location /ollama/ {
            access_by_lua_block {
                local auth_header = ngx.var.http_authorization
                if not auth_header then
                    ngx.status = 401
                    ngx.say('{"error": "Authorization required"}')
                    ngx.exit(401)
                end
            }
            
            proxy_pass http://ollama_backend/;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # Handle large request bodies for model uploads
            client_max_body_size 10G;
            proxy_request_buffering off;
            proxy_read_timeout 300s;
        }

        # ===== AUTH & API ENDPOINTS (LUA) =====
        
        # Simple auth endpoints using Lua instead of NJS
        location = /api/auth/login {
            content_by_lua_file /usr/local/openresty/nginx/lua/auth.lua;
        }

        location = /api/auth/register {
            content_by_lua_file /usr/local/openresty/nginx/lua/auth.lua;
        }

        location = /api/auth/verify {
            content_by_lua_file /usr/local/openresty/nginx/lua/auth.lua;
        }

        location ~ ^/api/admin/ {
            content_by_lua_file /usr/local/openresty/nginx/lua/admin.lua;
        }

        location = /api/init {
            content_by_lua_file /usr/local/openresty/nginx/lua/init.lua;
        }

        location = /health {
            content_by_lua_block {
                ngx.say('{"status": "healthy", "timestamp": "' .. ngx.utctime() .. '"}')
            }
        }

        # Static HTML page pretty routes
        location = / {
            try_files /index.html =404;
        }

        location = /login {
            try_files /login.html =404;
        }

        location = /register {
            try_files /register.html =404;
        }

        location = /chat {
            try_files /chat.html =404;
        }

        location = /admin {
            try_files /admin.html =404;
        }

        location = /user-detail {
            try_files /user-detail.html =404;
        }

        location = /unauthorised {
            try_files /unauthorised.html =404;
        }

        location = /rate_limit {
            try_files /rate_limit.html =404;
        }

        # Generic static fallback
        location / {
            try_files $uri $uri/ =404;
        }

        # Error pages
        error_page 404 /404.html;
        error_page 500 502 503 504 /50x.html;
        error_page 403 /unauthorised.html;
        error_page 429 /rate_limit.html;

        # Security headers
        add_header X-Frame-Options "SAMEORIGIN" always;
        add_header X-Content-Type-Options "nosniff" always;
        add_header X-XSS-Protection "1; mode=block" always;
        add_header Referrer-Policy "strict-origin-when-cross-origin" always;
    }
}