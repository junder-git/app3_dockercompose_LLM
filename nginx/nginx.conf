# Fixed nginx.conf with working chat API
user nobody;
worker_processes auto;
error_log /var/log/nginx/error.log warn;
pid /var/run/nginx.pid;

events {
    worker_connections 1024;
    use epoll;
}

http {
    include /usr/local/openresty/nginx/conf/mime.types;
    default_type application/octet-stream;

    # Security headers
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;

    # Upstreams
    upstream redis_backend {
        server devstral-redis:6379;
        keepalive 10;
    }

    upstream ollama_backend {
        server devstral-ollama:11434;
        keepalive 8;
    }

    # Redis connection settings
    redis2_connect_timeout 1s;
    redis2_send_timeout 1s;
    redis2_read_timeout 1s;

    server {
        listen 80;
        server_name localhost;

        root /usr/local/openresty/nginx/html;
        index index.html;

        # Hide nginx version
        server_tokens off;

        # Internal Redis operations
        location ~ ^/redis-internal/hgetall/(.+) {
            internal;
            redis2_query hgetall $1;
            redis2_pass redis_backend;
            redis2_literal_raw_query on;
        }

        location ~ ^/redis-internal/exists/(.+) {
            internal;
            redis2_query exists $1;
            redis2_pass redis_backend;
        }

        location ~ ^/redis-internal/del/(.+) {
            internal;
            redis2_query del $1;
            redis2_pass redis_backend;
        }

        location ~ ^/redis-internal/hset/(.+) {
            internal;
            set_by_lua_block $redis_cmd {
                local key_and_args = ngx.var[1]
                local parts = {}
                for part in key_and_args:gmatch("[^/]+") do
                    table.insert(parts, part)
                end
                
                local cmd = "hset"
                for i, part in ipairs(parts) do
                    cmd = cmd .. " " .. part
                end
                return cmd
            }
            redis2_raw_query $redis_cmd;
            redis2_pass redis_backend;
        }

        location ~ ^/redis-internal/hmset/(.+) {
            internal;
            set_by_lua_block $redis_cmd {
                local key_and_args = ngx.var[1]
                local parts = {}
                for part in key_and_args:gmatch("[^/]+") do
                    table.insert(parts, part)
                end
                
                local cmd = "hmset"
                for i, part in ipairs(parts) do
                    cmd = cmd .. " " .. part
                end
                return cmd
            }
            redis2_raw_query $redis_cmd;
            redis2_pass redis_backend;
        }

        # ===== AUTH ENDPOINTS =====
        
        location = /api/auth/login {
            content_by_lua_file /usr/local/openresty/nginx/lua/auth.lua;
        }

        location = /api/auth/register {
            content_by_lua_file /usr/local/openresty/nginx/lua/auth.lua;
        }

        location = /api/auth/verify {
            content_by_lua_file /usr/local/openresty/nginx/lua/auth.lua;
        }

        # ===== CHAT ENDPOINT - FIXED =====
        
        location /api/chat {
            # Simple auth check - don't overcomplicate it
            access_by_lua_block {
                local auth_header = ngx.var.http_authorization
                if not auth_header or not string.match(auth_header, "^Bearer ") then
                    ngx.log(ngx.ERR, "Chat API: No valid authorization header")
                    ngx.status = 401
                    ngx.header.content_type = "application/json"
                    ngx.say('{"error": "Authentication required"}')
                    ngx.exit(401)
                end
                
                -- Log successful auth
                ngx.log(ngx.INFO, "Chat API: Authentication successful")
            }
            
            # Enhanced proxy settings
            proxy_pass http://ollama_backend/api/chat;
            proxy_http_version 1.1;
            proxy_set_header Connection "";
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header Accept-Encoding "";
            
            # Pass through all headers
            proxy_pass_request_headers on;
            proxy_pass_request_body on;
            
            # Streaming support with longer timeouts
            proxy_buffering off;
            proxy_cache off;
            proxy_read_timeout 900s;
            proxy_send_timeout 900s;
            proxy_connect_timeout 60s;
            
            # Handle errors gracefully
            proxy_intercept_errors off;
            
            # Add CORS headers if needed
            add_header Access-Control-Allow-Origin *;
            add_header Access-Control-Allow-Methods "GET, POST, OPTIONS";
            add_header Access-Control-Allow-Headers "Origin, X-Requested-With, Content-Type, Accept, Authorization";
            
            # Handle preflight requests
            if ($request_method = 'OPTIONS') {
                add_header Access-Control-Allow-Origin *;
                add_header Access-Control-Allow-Methods "GET, POST, OPTIONS";
                add_header Access-Control-Allow-Headers "Origin, X-Requested-With, Content-Type, Accept, Authorization";
                add_header Access-Control-Max-Age 1728000;
                add_header Content-Type "text/plain; charset=utf-8";
                add_header Content-Length 0;
                return 204;
            }
        }

        # ===== TEST CHAT ENDPOINT - FOR DEBUGGING =====
        
        location = /api/chat/test {
            access_by_lua_block {
                local auth_header = ngx.var.http_authorization
                if not auth_header or not string.match(auth_header, "^Bearer ") then
                    ngx.status = 401
                    ngx.header.content_type = "application/json"
                    ngx.say('{"error": "Authentication required"}')
                    ngx.exit(401)
                end
            }
            
            content_by_lua_block {
                ngx.header.content_type = "application/json"
                ngx.say('{"message": {"content": "Chat API test successful! This is a test response from the chat endpoint."}, "status": "success"}')
            }
        }

        # ===== ADMIN ENDPOINTS =====
        
        location ~ ^/api/admin/(.+) {
            access_by_lua_block {
                local cjson = require "cjson"
                local auth_header = ngx.var.http_authorization
                
                if not auth_header or not string.match(auth_header, "^Bearer ") then
                    ngx.status = 403
                    ngx.header.content_type = "application/json"
                    ngx.say('{"error": "Admin authentication required"}')
                    ngx.exit(403)
                end
                
                local token = string.sub(auth_header, 8)
                local ok, payload = pcall(function()
                    return cjson.decode(ngx.decode_base64(token))
                end)
                
                if not ok or not payload.exp or payload.exp < ngx.time() or not payload.is_admin then
                    ngx.status = 403
                    ngx.header.content_type = "application/json"
                    ngx.say('{"error": "Admin privileges required"}')
                    ngx.exit(403)
                end
            }
            
            content_by_lua_file /usr/local/openresty/nginx/lua/admin.lua;
        }

        # ===== SECURE HTML ROUTES =====
        
        location = /chat {
            access_by_lua_block {
                local token = ngx.var.arg_token or ngx.var.cookie_auth_token
                local auth_header = ngx.var.http_authorization
                
                if auth_header and string.match(auth_header, "^Bearer ") then
                    token = string.sub(auth_header, 8)
                end
                
                if not token then
                    ngx.log(ngx.INFO, "No token found for /chat, serving page for client-side redirect")
                end
                
                if token then
                    local cjson = require "cjson"
                    local ok, payload = pcall(function()
                        return cjson.decode(ngx.decode_base64(token))
                    end)
                    
                    if not ok or not payload.exp or payload.exp < ngx.time() then
                        ngx.log(ngx.INFO, "Invalid token for /chat, serving page for client-side redirect")
                    end
                end
            }
            
            try_files /chat.html =404;
        }

        location = /admin {
            access_by_lua_block {
                local cjson = require "cjson"
                
                local token = ngx.var.arg_token or ngx.var.cookie_auth_token
                local auth_header = ngx.var.http_authorization
                
                if auth_header and string.match(auth_header, "^Bearer ") then
                    token = string.sub(auth_header, 8)
                end
                
                if not token then
                    ngx.log(ngx.WARN, "Admin access attempted without token from " .. ngx.var.remote_addr)
                    return ngx.redirect("/login")
                end
                
                local ok, payload = pcall(function()
                    return cjson.decode(ngx.decode_base64(token))
                end)
                
                if not ok or not payload.exp or payload.exp < ngx.time() then
                    ngx.log(ngx.WARN, "Admin access with invalid token from " .. ngx.var.remote_addr)
                    return ngx.redirect("/login")
                end
                
                if not payload.is_admin then
                    ngx.log(ngx.WARN, "Non-admin user attempted admin access: " .. (payload.username or "unknown"))
                    return ngx.redirect("/unauthorised")
                end
                
                local res = ngx.location.capture("/redis-internal/hgetall/user:" .. payload.username)
                if res.status ~= 200 then
                    ngx.log(ngx.WARN, "Admin access with non-existent user: " .. payload.username)
                    return ngx.redirect("/login")
                end
                
                ngx.log(ngx.INFO, "Admin access granted to: " .. payload.username)
            }
            
            try_files /admin.html =404;
        }

        # ===== PUBLIC ROUTES =====
        
        location = / { 
            try_files /index.html =404; 
        }
        
        location = /login { 
            try_files /login.html =404; 
        }
        
        location = /register { 
            try_files /register.html =404; 
        }

        # ===== HEALTH CHECK =====
        
        location = /health {
            content_by_lua_block {
                ngx.header.content_type = "application/json"
                ngx.say('{"status": "healthy", "timestamp": "' .. ngx.utctime() .. '"}')
            }
        }

        # ===== STATIC FILES =====
        
        location ~* \.(css|js|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$ {
            expires 1h;
            try_files $uri =404;
        }

        # ===== SECURITY BLOCKS =====
        
        location ~ /\. {
            deny all;
            access_log off;
            log_not_found off;
        }

        location ~* \.(conf|log|sql|sh|py)$ {
            deny all;
            access_log off;
            log_not_found off;
        }

        location / {
            try_files $uri $uri/ =404;
        }

        error_page 404 /404.html;
        error_page 403 /unauthorised.html;
        error_page 500 502 503 504 /50x.html;
    }
}