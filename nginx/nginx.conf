# OpenResty compatible nginx.conf
# Load required modules
load_module modules/ngx_http_js_module.so;
load_module modules/ngx_http_set_misc_module.so;

user nobody;
worker_processes auto;
error_log /var/log/nginx/error.log warn;
pid /var/run/nginx.pid;

events {
    worker_connections 1024;
    use epoll;
}

http {
    include /etc/nginx/mime.types;
    default_type application/octet-stream;

    # Import NJS modules (only for auth/routing logic)
    js_import auth from /etc/nginx/njs/auth.js;
    js_import utils from /etc/nginx/njs/utils.js;
    js_import admin from /etc/nginx/njs/admin.js;

    # Upstreams
    upstream redis_backend {
        server redis:6379;
        keepalive 10;
    }

    upstream ollama_backend {
        server ollama:11434;
        keepalive 8;
    }

    # Redis connection settings
    redis2_connect_timeout 1s;
    redis2_send_timeout 1s;
    redis2_read_timeout 1s;

    server {
        listen 80;
        server_name localhost;

        root /usr/local/openresty/nginx/html;
        index index.html;
        
        # ===== REDIS2 DIRECT ACCESS =====
        
        # Set Redis key-value
        # POST /redis/set with JSON: {"key": "mykey", "value": "myvalue"}
        location = /redis/set {
            access_by_lua_block {
                local auth_header = ngx.var.http_authorization
                if not auth_header then
                    ngx.status = 401
                    ngx.say('{"error": "Authorization required"}')
                    ngx.exit(401)
                end
                -- Allow internal requests
                if auth_header == "Bearer internal" then
                    return
                end
                -- Add proper auth validation here for external requests
            }
            
            content_by_lua_block {
                local cjson = require "cjson"
                ngx.req.read_body()
                local body = ngx.req.get_body_data()
                
                if not body then
                    ngx.status = 400
                    ngx.say('{"error": "Request body required"}')
                    return
                end
                
                local data = cjson.decode(body)
                if not data.key or not data.value then
                    ngx.status = 400
                    ngx.say('{"error": "Key and value required"}')
                    return
                end
                
                -- Set variables for redis2
                ngx.var.redis_key = data.key
                ngx.var.redis_value = data.value
                
                -- Execute redis command
                local res = ngx.location.capture("/redis-internal/set")
                if res.status == 200 then
                    ngx.say('{"success": true, "result": "' .. res.body:gsub('[\r\n]', '') .. '"}')
                else
                    ngx.status = 500
                    ngx.say('{"error": "Redis operation failed"}')
                end
            }
        }
        
        # Get Redis key value
        # GET /redis/get?key=mykey
        location = /redis/get {
            access_by_lua_block {
                local auth_header = ngx.var.http_authorization
                if not auth_header then
                    ngx.status = 401
                    ngx.say('{"error": "Authorization required"}')
                    ngx.exit(401)
                end
                -- Allow internal requests
                if auth_header == "Bearer internal" then
                    return
                end
            }
            
            set_unescape_uri $redis_key $arg_key;
            
            if ($redis_key = '') {
                return 400 '{"error": "Key parameter required"}';
            }
            
            redis2_query get $redis_key;
            redis2_pass redis_backend;
            
            # Format response as JSON
            header_filter_by_lua_block {
                ngx.header.content_type = "application/json"
            }
            
            body_filter_by_lua_block {
                if ngx.arg[2] then  -- last chunk
                    local body = ngx.arg[1]
                    if body then
                        body = body:gsub('[\r\n]', '')
                        if body == '$-1' or body == '' then
                            ngx.arg[1] = '{"success": true, "value": null}'
                        else
                            ngx.arg[1] = '{"success": true, "value": "' .. body .. '"}'
                        end
                    end
                end
            }
        }
        
        # Get all hash fields
        # GET /redis/hgetall?key=user:123
        location = /redis/hgetall {
            access_by_lua_block {
                local auth_header = ngx.var.http_authorization
                if not auth_header then
                    ngx.status = 401
                    ngx.say('{"error": "Authorization required"}')
                    ngx.exit(401)
                end
                -- Allow internal requests
                if auth_header == "Bearer internal" then
                    return
                end
            }
            
            set_unescape_uri $redis_key $arg_key;
            
            if ($redis_key = '') {
                return 400 '{"error": "Key parameter required"}';
            }
            
            redis2_query hgetall $redis_key;
            redis2_pass redis_backend;
            
            header_filter_by_lua_block {
                ngx.header.content_type = "application/json"
            }
            
            body_filter_by_lua_block {
                if ngx.arg[2] then  -- last chunk
                    local cjson = require "cjson"
                    local body = ngx.arg[1]
                    if body then
                        local lines = {}
                        for line in body:gmatch("[^\r\n]+") do
                            table.insert(lines, line)
                        end
                        
                        local result = {}
                        for i = 1, #lines, 2 do
                            if lines[i+1] then
                                result[lines[i]] = lines[i+1]
                            end
                        end
                        
                        ngx.arg[1] = cjson.encode({success = true, data = result})
                    end
                end
            }
        }
        
        # Set hash field
        # POST /redis/hset with JSON: {"key": "user:123", "field": "name", "value": "john"}
        location = /redis/hset {
            access_by_lua_block {
                local auth_header = ngx.var.http_authorization
                if not auth_header then
                    ngx.status = 401
                    ngx.say('{"error": "Authorization required"}')
                    ngx.exit(401)
                end
                -- Allow internal requests
                if auth_header == "Bearer internal" then
                    return
                end
            }
            
            content_by_lua_block {
                local cjson = require "cjson"
                ngx.req.read_body()
                local body = ngx.req.get_body_data()
                
                if not body then
                    ngx.status = 400
                    ngx.say('{"error": "Request body required"}')
                    return
                end
                
                local data = cjson.decode(body)
                if not data.key or not data.field or not data.value then
                    ngx.status = 400
                    ngx.say('{"error": "Key, field and value required"}')
                    return
                end
                
                ngx.var.redis_key = data.key
                ngx.var.redis_field = data.field  
                ngx.var.redis_value = data.value
                
                local res = ngx.location.capture("/redis-internal/hset")
                if res.status == 200 then
                    ngx.say('{"success": true, "result": "' .. res.body:gsub('[\r\n]', '') .. '"}')
                else
                    ngx.status = 500
                    ngx.say('{"error": "Redis operation failed"}')
                end
            }
        }
        
        # Internal Redis operations (called by Lua)
        location = /redis-internal/set {
            internal;
            redis2_query set $redis_key $redis_value;
            redis2_pass redis_backend;
        }
        
        location = /redis-internal/hset {
            internal;
            redis2_query hset $redis_key $redis_field $redis_value;
            redis2_pass redis_backend;
        }

        # ===== OLLAMA WEBSOCKET PROXY =====
        
        # WebSocket proxy for Ollama streaming
        location /ollama/api/chat {
            access_by_lua_block {
                local auth_header = ngx.var.http_authorization
                if not auth_header then
                    ngx.status = 401
                    ngx.say('{"error": "Authorization required"}')
                    ngx.exit(401)
                end
            }
            
            proxy_pass http://ollama_backend/api/chat;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # WebSocket specific settings
            proxy_buffering off;
            proxy_read_timeout 300s;
            proxy_connect_timeout 75s;
            
            # Handle streaming responses
            proxy_cache off;
            proxy_set_header Cache-Control no-cache;
        }
        
        # Regular HTTP proxy for Ollama non-streaming requests
        location /ollama/ {
            access_by_lua_block {
                local auth_header = ngx.var.http_authorization
                if not auth_header then
                    ngx.status = 401
                    ngx.say('{"error": "Authorization required"}')
                    ngx.exit(401)
                end
            }
            
            proxy_pass http://ollama_backend/;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # Handle large request bodies for model uploads
            client_max_body_size 10G;
            proxy_request_buffering off;
            proxy_read_timeout 300s;
        }

        # ===== AUTH & API ENDPOINTS (NJS) =====
        
        # Authentication endpoints (still use NJS for complex logic)
        location /api/auth/ {
            client_body_buffer_size 32k;
            client_max_body_size 32k;
            js_content auth.handleAuthRequest;
        }

        location /api/admin/ {
            client_body_buffer_size 32k;
            client_max_body_size 32k;
            js_content admin.handleAdminRequest;
        }

        location /api/init {
            js_content utils.handleInit;
        }

        location /health {
            js_content utils.healthCheck;
        }

        # Static HTML page pretty routes
        location = / {
            try_files /index.html =404;
        }

        location = /login {
            try_files /login.html =404;
        }

        location = /register {
            try_files /register.html =404;
        }

        location = /chat {
            try_files /chat.html =404;
        }

        location = /admin {
            try_files /admin.html =404;
        }

        location = /user-detail {
            try_files /user-detail.html =404;
        }

        location = /unauthorised {
            try_files /unauthorised.html =404;
        }

        location = /rate_limit {
            try_files /rate_limit.html =404;
        }

        # Generic static fallback
        location / {
            try_files $uri $uri/ =404;
        }

        # Error pages
        error_page 404 /404.html;
        error_page 500 502 503 504 /50x.html;
        error_page 403 /unauthorised.html;
        error_page 429 /rate_limit.html;

        # Security headers
        add_header X-Frame-Options "SAMEORIGIN" always;
        add_header X-Content-Type-Options "nosniff" always;
        add_header X-XSS-Protection "1; mode=block" always;
        add_header Referrer-Policy "strict-origin-when-cross-origin" always;
    }
}