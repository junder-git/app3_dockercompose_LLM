# Working nginx.conf with security that doesn't break functionality
user nobody;
worker_processes auto;
error_log /var/log/nginx/error.log warn;
pid /var/run/nginx.pid;

events {
    worker_connections 1024;
    use epoll;
}

http {
    include /usr/local/openresty/nginx/conf/mime.types;
    default_type application/octet-stream;

    # Basic security headers (safe ones)
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;

    # Rate limiting zones (more lenient)
    limit_req_zone $binary_remote_addr zone=auth_login:10m rate=10r/m;     # 10 login attempts per minute
    limit_req_zone $binary_remote_addr zone=auth_register:10m rate=5r/m;   # 5 registration attempts per minute
    limit_req_zone $binary_remote_addr zone=chat_api:10m rate=20r/m;       # 20 chat messages per minute
    limit_req_zone $binary_remote_addr zone=general:10m rate=60r/m;        # 60 general requests per minute

    # Upstreams
    upstream redis_backend {
        server devstral-redis:6379;
        keepalive 10;
    }

    upstream ollama_backend {
        server devstral-ollama:11434;
        keepalive 8;
    }

    # Redis connection settings
    redis2_connect_timeout 1s;
    redis2_send_timeout 1s;
    redis2_read_timeout 1s;

    server {
        listen 80;
        server_name localhost;

        root /usr/local/openresty/nginx/html;
        index index.html;

        # Hide nginx version
        server_tokens off;

        # Internal Redis operations (unchanged - these work)
        location ~ ^/redis-internal/hgetall/(.+) {
            internal;
            redis2_query hgetall $1;
            redis2_pass redis_backend;
            redis2_literal_raw_query on;
        }

        location ~ ^/redis-internal/exists/(.+) {
            internal;
            redis2_query exists $1;
            redis2_pass redis_backend;
        }

        location ~ ^/redis-internal/del/(.+) {
            internal;
            redis2_query del $1;
            redis2_pass redis_backend;
        }

        location ~ ^/redis-internal/hset/(.+) {
            internal;
            set_by_lua_block $redis_cmd {
                local key_and_args = ngx.var[1]
                local parts = {}
                for part in key_and_args:gmatch("[^/]+") do
                    table.insert(parts, part)
                end
                
                local cmd = "hset"
                for i, part in ipairs(parts) do
                    cmd = cmd .. " " .. part
                end
                return cmd
            }
            redis2_raw_query $redis_cmd;
            redis2_pass redis_backend;
        }

        location ~ ^/redis-internal/hmset/(.+) {
            internal;
            set_by_lua_block $redis_cmd {
                local key_and_args = ngx.var[1]
                local parts = {}
                for part in key_and_args:gmatch("[^/]+") do
                    table.insert(parts, part)
                end
                
                local cmd = "hmset"
                for i, part in ipairs(parts) do
                    cmd = cmd .. " " .. part
                end
                return cmd
            }
            redis2_raw_query $redis_cmd;
            redis2_pass redis_backend;
        }

        # ===== AUTH ENDPOINTS WITH GENTLE RATE LIMITING =====
        
        location = /api/auth/login {
            # Gentle rate limiting - allows bursts
            limit_req zone=auth_login burst=3 nodelay;
            
            # Log login attempts
            access_log /var/log/nginx/auth_login.log combined;
            
            # Use original working auth.lua
            content_by_lua_file /usr/local/openresty/nginx/lua/auth.lua;
        }

        location = /api/auth/register {
            # Gentle rate limiting
            limit_req zone=auth_register burst=2 nodelay;
            
            # Log registration attempts
            access_log /var/log/nginx/auth_register.log combined;
            
            content_by_lua_file /usr/local/openresty/nginx/lua/auth.lua;
        }

        location = /api/auth/verify {
            # More generous rate limiting for token verification
            limit_req zone=general burst=10 nodelay;
            
            content_by_lua_file /usr/local/openresty/nginx/lua/auth.lua;
        }

        # ===== CHAT ENDPOINT WITH SIMPLE AUTH CHECK =====
        
        location /api/chat {
            # Rate limiting for chat
            limit_req zone=chat_api burst=5 nodelay;
            
            # Simple auth check without breaking functionality
            access_by_lua_block {
                local auth_header = ngx.var.http_authorization
                if not auth_header or not string.match(auth_header, "^Bearer ") then
                    ngx.status = 401
                    ngx.header.content_type = "application/json"
                    ngx.say('{"error": "Authentication required"}')
                    ngx.exit(401)
                end
            }
            
            proxy_pass http://ollama_backend/api/chat;
            proxy_http_version 1.1;
            proxy_set_header Connection "";
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # Streaming support
            proxy_buffering off;
            proxy_cache off;
            proxy_read_timeout 300s;
            proxy_send_timeout 300s;
            proxy_connect_timeout 30s;
        }

        # ===== ADMIN ENDPOINTS WITH SIMPLE AUTH CHECK =====
        
        location ~ ^/api/admin/(.+) {
            # Rate limiting for admin
            limit_req zone=general burst=10 nodelay;
            
            # Simple admin auth check
            access_by_lua_block {
                local cjson = require "cjson"
                local auth_header = ngx.var.http_authorization
                
                if not auth_header or not string.match(auth_header, "^Bearer ") then
                    ngx.status = 403
                    ngx.header.content_type = "application/json"
                    ngx.say('{"error": "Admin authentication required"}')
                    ngx.exit(403)
                end
                
                local token = string.sub(auth_header, 8)
                local ok, payload = pcall(function()
                    return cjson.decode(ngx.decode_base64(token))
                end)
                
                if not ok or not payload.exp or payload.exp < ngx.time() or not payload.is_admin then
                    ngx.status = 403
                    ngx.header.content_type = "application/json"
                    ngx.say('{"error": "Admin privileges required"}')
                    ngx.exit(403)
                end
            }
            
            content_by_lua_file /usr/local/openresty/nginx/lua/admin.lua;
        }

        # ===== PROTECTED HTML ROUTES WITH SIMPLE CHECKS =====
        
        location = /chat {
            # Simple auth check - redirect if no token
            access_by_lua_block {
                local auth_header = ngx.var.http_authorization
                local token = ngx.var.cookie_auth_token or ngx.var.arg_token
                
                -- Check for token in various places
                if not auth_header and not token then
                    -- If no token found, redirect to login
                    return ngx.redirect("/login")
                end
            }
            
            try_files /chat.html =404;
        }
        
        location = /admin {
            # Simple admin check - redirect if not admin
            access_by_lua_block {
                local cjson = require "cjson"
                local auth_header = ngx.var.http_authorization
                local token = ngx.var.cookie_auth_token or ngx.var.arg_token
                
                -- For now, just redirect to login if no token
                -- Real auth check happens in JavaScript
                if not auth_header and not token then
                    return ngx.redirect("/login")
                end
            }
            
            try_files /admin.html =404;
        }

        # ===== PUBLIC ROUTES WITH BASIC RATE LIMITING =====
        
        location = / { 
            limit_req zone=general burst=20 nodelay;
            try_files /index.html =404; 
        }
        
        location = /login { 
            limit_req zone=general burst=20 nodelay;
            try_files /login.html =404; 
        }
        
        location = /register { 
            limit_req zone=general burst=20 nodelay;
            try_files /register.html =404; 
        }

        # ===== STATIC FILES =====
        
        location ~* \.(css|js|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$ {
            limit_req zone=general burst=50 nodelay;
            expires 1h;
            try_files $uri =404;
        }

        # ===== HEALTH CHECK =====
        
        location = /health {
            access_log off;
            content_by_lua_block {
                ngx.header.content_type = "application/json"
                ngx.say('{"status": "healthy", "timestamp": "' .. ngx.utctime() .. '"}')
            }
        }

        # ===== BASIC SECURITY BLOCKS =====
        
        # Block access to hidden files
        location ~ /\. {
            deny all;
            access_log off;
            log_not_found off;
        }

        # Block access to sensitive files
        location ~* \.(conf|log|sql|sh|py)$ {
            deny all;
            access_log off;
            log_not_found off;
        }

        # Default handler
        location / {
            limit_req zone=general burst=20 nodelay;
            try_files $uri $uri/ =404;
        }

        # Error pages
        error_page 404 /404.html;
        error_page 403 /unauthorised.html;
        error_page 429 /rate_limit.html;
        error_page 500 502 503 504 /50x.html;
    }
}