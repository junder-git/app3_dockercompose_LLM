# Enhanced nginx.conf with chat persistence support
user nobody;
worker_processes auto;
error_log /var/log/nginx/error.log warn;
pid /var/run/nginx.pid;

events {
    worker_connections 1024;
    use epoll;
}

http {
    include /usr/local/openresty/nginx/conf/mime.types;
    default_type application/octet-stream;

    # Enhanced logging
    log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                    '$status $body_bytes_sent "$http_referer" '
                    '"$http_user_agent" "$http_x_forwarded_for"';
    
    access_log /var/log/nginx/access.log main;

    # Security headers
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header Referrer-Policy "strict-origin-when-cross-origin" always;

    # Performance optimizations
    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout 65;
    types_hash_max_size 2048;

    # Gzip compression
    gzip on;
    gzip_vary on;
    gzip_min_length 1024;
    gzip_types text/plain text/css text/xml text/javascript application/javascript application/json;

    # Upstreams with health checks
    upstream redis_backend {
        server devstral-redis:6379;
        keepalive 10;
    }

    upstream ollama_backend {
        server devstral-ollama:11434;
        keepalive 8;
    }

    # Redis connection settings
    redis2_connect_timeout 5s;
    redis2_send_timeout 10s;
    redis2_read_timeout 10s;

    server {
        listen 80;
        server_name localhost;

        root /usr/local/openresty/nginx/html;
        index index.html;

        # Hide nginx version
        server_tokens off;

        # Enhanced client settings
        client_max_body_size 10M;
        client_body_timeout 60s;
        client_header_timeout 60s;
        send_timeout 60s;

        # Internal Redis operations
        location ~ ^/redis-internal/hgetall/(.+) {
            internal;
            redis2_query hgetall $1;
            redis2_pass redis_backend;
            redis2_literal_raw_query on;
        }

        location ~ ^/redis-internal/hget/(.+) {
            internal;
            set_by_lua_block $redis_cmd {
                local key_and_field = ngx.var[1]
                local parts = {}
                for part in key_and_field:gmatch("[^/]+") do
                    table.insert(parts, part)
                end
                return "hget " .. parts[1] .. " " .. parts[2]
            }
            redis2_raw_query $redis_cmd;
            redis2_pass redis_backend;
        }

        location ~ ^/redis-internal/exists/(.+) {
            internal;
            redis2_query exists $1;
            redis2_pass redis_backend;
        }

        location ~ ^/redis-internal/del/(.+) {
            internal;
            redis2_query del $1;
            redis2_pass redis_backend;
        }

        location ~ ^/redis-internal/keys/(.+) {
            internal;
            redis2_query keys $1;
            redis2_pass redis_backend;
        }

        location ~ ^/redis-internal/sadd/(.+) {
            internal;
            set_by_lua_block $redis_cmd {
                local key_and_member = ngx.var[1]
                local parts = {}
                for part in key_and_member:gmatch("[^/]+") do
                    table.insert(parts, part)
                end
                return "sadd " .. parts[1] .. " " .. parts[2]
            }
            redis2_raw_query $redis_cmd;
            redis2_pass redis_backend;
        }

        location ~ ^/redis-internal/srem/(.+) {
            internal;
            set_by_lua_block $redis_cmd {
                local key_and_member = ngx.var[1]
                local parts = {}
                for part in key_and_member:gmatch("[^/]+") do
                    table.insert(parts, part)
                end
                return "srem " .. parts[1] .. " " .. parts[2]
            }
            redis2_raw_query $redis_cmd;
            redis2_pass redis_backend;
        }

        location ~ ^/redis-internal/smembers/(.+) {
            internal;
            redis2_query smembers $1;
            redis2_pass redis_backend;
        }

        location ~ ^/redis-internal/hset/(.+) {
            internal;
            set_by_lua_block $redis_cmd {
                local key_and_args = ngx.var[1]
                local parts = {}
                for part in key_and_args:gmatch("[^/]+") do
                    table.insert(parts, part)
                end
                
                local cmd = "hset"
                for i, part in ipairs(parts) do
                    cmd = cmd .. " " .. part
                end
                return cmd
            }
            redis2_raw_query $redis_cmd;
            redis2_pass redis_backend;
        }

        location ~ ^/redis-internal/hmset/(.+) {
            internal;
            set_by_lua_block $redis_cmd {
                local key_and_args = ngx.var[1]
                local parts = {}
                for part in key_and_args:gmatch("[^/]+") do
                    table.insert(parts, part)
                end
                
                local cmd = "hmset"
                for i, part in ipairs(parts) do
                    cmd = cmd .. " " .. part
                end
                return cmd
            }
            redis2_raw_query $redis_cmd;
            redis2_pass redis_backend;
        }

        location ~ ^/redis-internal/ping {
            internal;
            redis2_query ping;
            redis2_pass redis_backend;
        }

        # ===== AUTH ENDPOINTS =====
        
        location = /api/auth/login {
            content_by_lua_file /usr/local/openresty/nginx/lua/auth.lua;
        }

        location = /api/auth/register {
            content_by_lua_file /usr/local/openresty/nginx/lua/auth.lua;
        }

        location = /api/auth/verify {
            content_by_lua_file /usr/local/openresty/nginx/lua/auth.lua;
        }

        # ===== CHAT PERSISTENCE ENDPOINTS =====
        
        location = /api/chat/save {
            content_by_lua_file /usr/local/openresty/nginx/lua/chat.lua;
        }

        location ~ ^/api/chat/load/(.+) {
            content_by_lua_file /usr/local/openresty/nginx/lua/chat.lua;
        }

        location = /api/chat/list {
            content_by_lua_file /usr/local/openresty/nginx/lua/chat.lua;
        }

        location ~ ^/api/chat/delete/(.+) {
            content_by_lua_file /usr/local/openresty/nginx/lua/chat.lua;
        }

        # ===== CHAT ENDPOINTS =====

        location = /api/chat/save {
            access_by_lua_block {
                local cjson = require "cjson"
                local auth_header = ngx.var.http_authorization
                
                if not auth_header or not string.match(auth_header, "^Bearer ") then
                    ngx.status = 401
                    ngx.header.content_type = "application/json"
                    ngx.say('{"error": "Authentication required"}')
                    ngx.exit(401)
                end
                
                local token = string.sub(auth_header, 8)
                local ok, payload = pcall(function()
                    return cjson.decode(ngx.decode_base64(token))
                end)
                
                if not ok or not payload.exp or payload.exp < ngx.time() then
                    ngx.status = 401
                    ngx.header.content_type = "application/json"
                    ngx.say('{"error": "Invalid or expired token"}')
                    ngx.exit(401)
                end
            }
            
            content_by_lua_block {
                local cjson = require "cjson"
                
                if ngx.var.request_method ~= "POST" then
                    ngx.status = 405
                    ngx.header.content_type = "application/json"
                    ngx.say('{"error": "Method not allowed"}')
                    return
                end

                ngx.req.read_body()
                local body = ngx.req.get_body_data()
                
                if not body then
                    ngx.status = 400
                    ngx.header.content_type = "application/json"
                    ngx.say('{"error": "Request body required"}')
                    return
                end

                local ok, chat_data = pcall(cjson.decode, body)
                if not ok then
                    ngx.status = 400
                    ngx.header.content_type = "application/json"
                    ngx.say('{"error": "Invalid JSON"}')
                    return
                end

                if not chat_data.id or not chat_data.user_id or not chat_data.messages then
                    ngx.status = 400
                    ngx.header.content_type = "application/json"
                    ngx.say('{"error": "Missing required fields"}')
                    return
                end

                local chat_key = "chat:" .. chat_data.id
                local messages_json = cjson.encode(chat_data.messages)
                local title = chat_data.title or "New Chat"
                local timestamp = ngx.utctime()
                
                local save_result = ngx.location.capture("/redis-internal/hmset/" .. chat_key .. 
                    "/id/" .. chat_data.id ..
                    "/user_id/" .. chat_data.user_id ..
                    "/title/" .. ngx.escape_uri(title) ..
                    "/messages/" .. ngx.escape_uri(messages_json) ..
                    "/created_at/" .. timestamp ..
                    "/updated_at/" .. timestamp)

                if save_result.status == 200 then
                    ngx.header.content_type = "application/json"
                    ngx.say('{"success": true, "message": "Chat saved successfully", "chat_id": "' .. chat_data.id .. '"}')
                else
                    ngx.status = 500
                    ngx.header.content_type = "application/json"
                    ngx.say('{"error": "Failed to save chat"}')
                end
            }
        }

        location ~ ^/api/chat/load/(.+) {
            access_by_lua_block {
                local cjson = require "cjson"
                local auth_header = ngx.var.http_authorization
                
                if not auth_header or not string.match(auth_header, "^Bearer ") then
                    ngx.status = 401
                    ngx.header.content_type = "application/json"
                    ngx.say('{"error": "Authentication required"}')
                    ngx.exit(401)
                end
                
                local token = string.sub(auth_header, 8)
                local ok, payload = pcall(function()
                    return cjson.decode(ngx.decode_base64(token))
                end)
                
                if not ok or not payload.exp or payload.exp < ngx.time() then
                    ngx.status = 401
                    ngx.header.content_type = "application/json"
                    ngx.say('{"error": "Invalid or expired token"}')
                    ngx.exit(401)
                end
            }
            
            content_by_lua_block {
                local cjson = require "cjson"
                
                local chat_id = ngx.var[1]
                if not chat_id then
                    ngx.status = 400
                    ngx.header.content_type = "application/json"
                    ngx.say('{"error": "Chat ID required"}')
                    return
                end

                local chat_key = "chat:" .. chat_id
                local result = ngx.location.capture("/redis-internal/hgetall/" .. chat_key)
                
                if result.status ~= 200 then
                    ngx.status = 500
                    ngx.header.content_type = "application/json"
                    ngx.say('{"error": "Failed to load chat"}')
                    return
                end

                local chat_data = {}
                local lines = {}
                for line in result.body:gmatch("[^\r\n]+") do
                    if line and line ~= "" then
                        table.insert(lines, line)
                    end
                end

                local i = 1
                if lines[i] and string.match(lines[i], "^%*%d+$") then
                    i = i + 1
                end

                while i <= #lines do
                    if lines[i] and string.match(lines[i], "^%$%d+$") then
                        i = i + 1
                        if lines[i] then
                            local key = lines[i]
                            i = i + 1
                            
                            if lines[i] and string.match(lines[i], "^%$%d+$") then
                                i = i + 1
                                if lines[i] then
                                    local value = lines[i]
                                    chat_data[key] = value
                                end
                            end
                        end
                    end
                    i = i + 1
                end

                if not chat_data.id then
                    ngx.status = 404
                    ngx.header.content_type = "application/json"
                    ngx.say('{"error": "Chat not found"}')
                    return
                end

                local messages = {}
                if chat_data.messages then
                    local ok, parsed_messages = pcall(cjson.decode, ngx.unescape_uri(chat_data.messages))
                    if ok then
                        messages = parsed_messages
                    end
                end

                local response_data = {
                    id = chat_data.id,
                    user_id = chat_data.user_id,
                    title = ngx.unescape_uri(chat_data.title or "New Chat"),
                    messages = messages,
                    created_at = chat_data.created_at,
                    updated_at = chat_data.updated_at
                }

                ngx.header.content_type = "application/json"
                ngx.say(cjson.encode(response_data))
            }
        }
        
        location /api/chat {
            # Skip persistence endpoints
            if ($uri ~ ^/api/chat/(save|load|list|delete|test)) {
                break;
            }
            
            # Enhanced authentication check
            access_by_lua_block {
                local cjson = require "cjson"
                local auth_header = ngx.var.http_authorization
                
                if not auth_header or not string.match(auth_header, "^Bearer ") then
                    ngx.log(ngx.ERR, "Chat API: No valid authorization header from " .. ngx.var.remote_addr)
                    ngx.status = 401
                    ngx.header.content_type = "application/json"
                    ngx.say('{"error": "Authentication required"}')
                    ngx.exit(401)
                end
                
                local token = string.sub(auth_header, 8)
                local ok, payload = pcall(function()
                    return cjson.decode(ngx.decode_base64(token))
                end)
                
                if not ok or not payload.exp or payload.exp < ngx.time() then
                    ngx.log(ngx.ERR, "Chat API: Invalid or expired token from " .. ngx.var.remote_addr)
                    ngx.status = 401
                    ngx.header.content_type = "application/json"
                    ngx.say('{"error": "Invalid or expired token"}')
                    ngx.exit(401)
                end
                
                ngx.log(ngx.INFO, "Chat API: Authentication successful for " .. (payload.username or "unknown"))
            }
            
            # Enhanced proxy configuration
            proxy_pass http://ollama_backend/api/chat;
            proxy_http_version 1.1;
            proxy_set_header Connection "";
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header Accept-Encoding "";
            
            proxy_pass_request_headers on;
            proxy_pass_request_body on;
            
            # Enhanced timeout settings for hybrid mode
            proxy_buffering off;
            proxy_cache off;
            proxy_read_timeout 600s;
            proxy_send_timeout 600s;
            proxy_connect_timeout 30s;
            
            # Error handling
            proxy_intercept_errors off;
            proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504;
            proxy_next_upstream_timeout 60s;
            proxy_next_upstream_tries 3;
            
            # CORS headers
            add_header Access-Control-Allow-Origin *;
            add_header Access-Control-Allow-Methods "GET, POST, OPTIONS";
            add_header Access-Control-Allow-Headers "Origin, X-Requested-With, Content-Type, Accept, Authorization";
            
            if ($request_method = 'OPTIONS') {
                add_header Access-Control-Allow-Origin *;
                add_header Access-Control-Allow-Methods "GET, POST, OPTIONS";
                add_header Access-Control-Allow-Headers "Origin, X-Requested-With, Content-Type, Accept, Authorization";
                add_header Access-Control-Max-Age 1728000;
                add_header Content-Type "text/plain; charset=utf-8";
                add_header Content-Length 0;
                return 204;
            }
        }

        # ===== ENHANCED TEST CHAT ENDPOINT =====
        
        location = /api/chat/test {
            access_by_lua_block {
                local cjson = require "cjson"
                local auth_header = ngx.var.http_authorization
                
                if not auth_header or not string.match(auth_header, "^Bearer ") then
                    ngx.status = 401
                    ngx.header.content_type = "application/json"
                    ngx.say('{"error": "Authentication required"}')
                    ngx.exit(401)
                end
                
                local token = string.sub(auth_header, 8)
                local ok, payload = pcall(function()
                    return cjson.decode(ngx.decode_base64(token))
                end)
                
                if not ok or not payload.exp or payload.exp < ngx.time() then
                    ngx.status = 401
                    ngx.header.content_type = "application/json"
                    ngx.say('{"error": "Invalid or expired token"}')
                    ngx.exit(401)
                end
            }
            
            content_by_lua_block {
                -- Test both Redis and Ollama connectivity
                local redis_ok = false
                local ollama_ok = false
                
                -- Test Redis
                local redis_res = ngx.location.capture("/redis-internal/ping")
                if redis_res.status == 200 and redis_res.body:match("PONG") then
                    redis_ok = true
                end
                
                -- Test Ollama
                local ollama_res = ngx.location.capture_multi({
                    {"/proxy-ollama-tags"}
                })
                if ollama_res[1].status == 200 then
                    ollama_ok = true
                end
                
                local status = "ok"
                local message = "Chat services are operational"
                
                if not redis_ok then
                    status = "error"
                    message = "Redis connection failed"
                elseif not ollama_ok then
                    status = "warning"
                    message = "AI service may be unavailable"
                end
                
                ngx.header.content_type = "application/json"
                ngx.say('{"message": {"content": "' .. message .. '"}, "status": "' .. status .. '", "redis": ' .. (redis_ok and "true" or "false") .. ', "ollama": ' .. (ollama_ok and "true" or "false") .. ', "timestamp": "' .. ngx.utctime() .. '"}')
            }
        }

        # Internal proxy for Ollama tags
        location = /proxy-ollama-tags {
            internal;
            proxy_pass http://ollama_backend/api/tags;
            proxy_method GET;
            proxy_set_header Host $host;
            proxy_connect_timeout 5s;
            proxy_read_timeout 5s;
            proxy_send_timeout 5s;
        }

        # ===== ADMIN ENDPOINTS =====
        
        location ~ ^/api/admin/(.+) {
            access_by_lua_block {
                local cjson = require "cjson"
                local auth_header = ngx.var.http_authorization
                
                if not auth_header or not string.match(auth_header, "^Bearer ") then
                    ngx.status = 403
                    ngx.header.content_type = "application/json"
                    ngx.say('{"error": "Admin authentication required"}')
                    ngx.exit(403)
                end
                
                local token = string.sub(auth_header, 8)
                local ok, payload = pcall(function()
                    return cjson.decode(ngx.decode_base64(token))
                end)
                
                if not ok or not payload.exp or payload.exp < ngx.time() or not payload.is_admin then
                    ngx.status = 403
                    ngx.header.content_type = "application/json"
                    ngx.say('{"error": "Admin privileges required"}')
                    ngx.exit(403)
                end
            }
            
            content_by_lua_file /usr/local/openresty/nginx/lua/admin.lua;
        }

        # ===== SECURE HTML ROUTES =====
        
        location = /chat {
            access_by_lua_block {
                local token = ngx.var.arg_token or ngx.var.cookie_auth_token
                local auth_header = ngx.var.http_authorization
                
                if auth_header and string.match(auth_header, "^Bearer ") then
                    token = string.sub(auth_header, 8)
                end
                
                if not token then
                    ngx.log(ngx.INFO, "No token found for /chat, serving page for client-side redirect")
                end
                
                if token then
                    local cjson = require "cjson"
                    local ok, payload = pcall(function()
                        return cjson.decode(ngx.decode_base64(token))
                    end)
                    
                    if not ok or not payload.exp or payload.exp < ngx.time() then
                        ngx.log(ngx.INFO, "Invalid token for /chat, serving page for client-side redirect")
                    end
                end
            }
            
            try_files /chat.html =404;
        }

        location = /admin {
            access_by_lua_block {
                local cjson = require "cjson"
                
                local token = ngx.var.arg_token or ngx.var.cookie_auth_token
                local auth_header = ngx.var.http_authorization
                
                if auth_header and string.match(auth_header, "^Bearer ") then
                    token = string.sub(auth_header, 8)
                end
                
                if not token then
                    ngx.log(ngx.WARN, "Admin access attempted without token from " .. ngx.var.remote_addr)
                    return ngx.redirect("/login")
                end
                
                local ok, payload = pcall(function()
                    return cjson.decode(ngx.decode_base64(token))
                end)
                
                if not ok or not payload.exp or payload.exp < ngx.time() then
                    ngx.log(ngx.WARN, "Admin access with invalid token from " .. ngx.var.remote_addr)
                    return ngx.redirect("/login")
                end
                
                if not payload.is_admin then
                    ngx.log(ngx.WARN, "Non-admin user attempted admin access: " .. (payload.username or "unknown"))
                    return ngx.redirect("/unauthorised")
                end
                
                local res = ngx.location.capture("/redis-internal/hgetall/user:" .. payload.username)
                if res.status ~= 200 then
                    ngx.log(ngx.WARN, "Admin access with non-existent user: " .. payload.username)
                    return ngx.redirect("/login")
                end
                
                ngx.log(ngx.INFO, "Admin access granted to: " .. payload.username)
            }
            
            try_files /admin.html =404;
        }

        # ===== PUBLIC ROUTES =====
        
        location = / { 
            try_files /index.html =404; 
        }
        
        location = /login { 
            try_files /login.html =404; 
        }
        
        location = /register { 
            try_files /register.html =404; 
        }

        location = /unauthorised { 
            try_files /unauthorised.html =404; 
        }

        # ===== HEALTH CHECK =====
        
        location = /health {
            access_log off;
            content_by_lua_block {
                -- Check Redis
                local redis_ok = false
                local redis_res = ngx.location.capture("/redis-internal/ping")
                if redis_res.status == 200 and redis_res.body:match("PONG") then
                    redis_ok = true
                end
                
                -- Check Ollama
                local ollama_ok = false
                local ollama_res = ngx.location.capture_multi({
                    {"/proxy-ollama-tags"}
                })
                if ollama_res[1].status == 200 then
                    ollama_ok = true
                end
                
                local status = "healthy"
                if not redis_ok or not ollama_ok then
                    status = "degraded"
                end
                
                ngx.header.content_type = "application/json"
                ngx.say('{"status": "' .. status .. '", "timestamp": "' .. ngx.utctime() .. '", "redis": ' .. (redis_ok and "true" or "false") .. ', "ollama": ' .. (ollama_ok and "true" or "false") .. '}')
            }
        }

        # ===== STATIC FILES =====
        
        location ~* \.(css|js|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$ {
            expires 1h;
            add_header Cache-Control "public, immutable";
            try_files $uri =404;
        }

        # ===== RATE LIMITING =====
        
        location /api/ {
            limit_req zone=api burst=10 nodelay;
            limit_req_status 429;
        }

        # ===== SECURITY BLOCKS =====
        
        location ~ /\. {
            deny all;
            access_log off;
            log_not_found off;
        }

        location ~* \.(conf|log|sql|sh|py|bak|old|tmp)$ {
            deny all;
            access_log off;
            log_not_found off;
        }

        location / {
            try_files $uri $uri/ =404;
        }

        # ===== ERROR PAGES =====
        
        error_page 404 /404.html;
        error_page 403 /unauthorised.html;
        error_page 429 /rate_limit.html;
        error_page 500 502 503 504 /50x.html;
    }

    # Rate limiting zones
    limit_req_zone $binary_remote_addr zone=api:10m rate=30r/m;
    limit_req_zone $binary_remote_addr zone=auth:10m rate=5r/m;
}