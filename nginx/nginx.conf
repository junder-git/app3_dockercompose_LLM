# Debug nginx.conf with extensive logging
user nobody;
worker_processes auto;
error_log /var/log/nginx/error.log debug;  # Changed to debug level
pid /var/run/nginx.pid;

events {
    worker_connections 1024;
    use epoll;
}

http {
    include /usr/local/openresty/nginx/conf/mime.types;
    default_type application/octet-stream;

    # Initialize admin user on startup
    init_by_lua_block {
        local cjson = require "cjson"
        
        ngx.log(ngx.ERR, "=== INIT_BY_LUA_BLOCK START ===")
        
        -- Get admin credentials from environment variables
        local admin_username = os.getenv("ADMIN_USERNAME") or "admin1"
        local admin_password = os.getenv("ADMIN_PASSWORD") or "admin1"
        local admin_user_id = os.getenv("ADMIN_USER_ID") or "admin"
        
        ngx.log(ngx.ERR, "INIT: Reading environment variables")
        ngx.log(ngx.ERR, "INIT: ADMIN_USERNAME = " .. admin_username)
        ngx.log(ngx.ERR, "INIT: ADMIN_PASSWORD = " .. admin_password)
        ngx.log(ngx.ERR, "INIT: ADMIN_USER_ID = " .. admin_user_id)
        
        -- Store in global variables for later use
        ngx.shared.config:set("admin_username", admin_username)
        ngx.shared.config:set("admin_password", admin_password)
        ngx.shared.config:set("admin_user_id", admin_user_id)
        
        ngx.log(ngx.ERR, "INIT: Stored admin credentials in shared memory")
        ngx.log(ngx.ERR, "=== INIT_BY_LUA_BLOCK END ===")
    }

    # Initialize admin user per worker with detailed logging
    init_worker_by_lua_block {
        local cjson = require "cjson"
        local redis = require "resty.redis"
        
        ngx.log(ngx.ERR, "=== INIT_WORKER_BY_LUA_BLOCK START ===")
        ngx.log(ngx.ERR, "WORKER INIT: Worker ID: " .. tostring(ngx.worker.id()))
        
        -- Only run in first worker to avoid race conditions
        if ngx.worker.id() ~= 0 then
            ngx.log(ngx.ERR, "WORKER INIT: Skipping - not worker 0")
            ngx.log(ngx.ERR, "=== INIT_WORKER_BY_LUA_BLOCK END (SKIPPED) ===")
            return
        end
        
        ngx.log(ngx.ERR, "WORKER INIT: Running in worker 0")
        
        -- Get admin credentials from shared memory
        local admin_username = ngx.shared.config:get("admin_username")
        local admin_password = ngx.shared.config:get("admin_password")
        local admin_user_id = ngx.shared.config:get("admin_user_id")
        
        ngx.log(ngx.ERR, "WORKER INIT: Retrieved from shared memory:")
        ngx.log(ngx.ERR, "WORKER INIT: admin_username = " .. (admin_username or "nil"))
        ngx.log(ngx.ERR, "WORKER INIT: admin_password = " .. (admin_password or "nil"))
        ngx.log(ngx.ERR, "WORKER INIT: admin_user_id = " .. (admin_user_id or "nil"))
        
        if not admin_username or not admin_password or not admin_user_id then
            ngx.log(ngx.ERR, "WORKER INIT: Missing admin credentials in shared memory!")
            ngx.log(ngx.ERR, "=== INIT_WORKER_BY_LUA_BLOCK END (ERROR) ===")
            return
        end
        
        ngx.log(ngx.ERR, "WORKER INIT: Attempting to connect to Redis...")
        
        -- Connect to Redis
        local red = redis:new()
        red:set_timeouts(1000, 1000, 1000)
        
        local ok, err = red:connect("redis", 6379)
        if not ok then
            ngx.log(ngx.ERR, "WORKER INIT: Failed to connect to Redis: " .. (err or "unknown"))
            ngx.log(ngx.ERR, "=== INIT_WORKER_BY_LUA_BLOCK END (REDIS ERROR) ===")
            return
        end
        
        ngx.log(ngx.ERR, "WORKER INIT: Successfully connected to Redis")
        
        -- Test Redis connection
        local pong, err = red:ping()
        if not pong then
            ngx.log(ngx.ERR, "WORKER INIT: Redis ping failed: " .. (err or "unknown"))
            red:close()
            ngx.log(ngx.ERR, "=== INIT_WORKER_BY_LUA_BLOCK END (PING ERROR) ===")
            return
        end
        
        ngx.log(ngx.ERR, "WORKER INIT: Redis ping successful: " .. tostring(pong))
        
        -- Check if admin user exists
        ngx.log(ngx.ERR, "WORKER INIT: Checking if admin user exists: user:" .. admin_username)
        
        local exists, err = red:exists("user:" .. admin_username)
        if err then
            ngx.log(ngx.ERR, "WORKER INIT: Error checking user existence: " .. err)
            red:close()
            ngx.log(ngx.ERR, "=== INIT_WORKER_BY_LUA_BLOCK END (EXISTS ERROR) ===")
            return
        end
        
        ngx.log(ngx.ERR, "WORKER INIT: User exists check result: " .. tostring(exists))
        
        if exists == 1 then
            ngx.log(ngx.ERR, "WORKER INIT: Admin user already exists - fetching data for verification")
            
            local user_data, err = red:hgetall("user:" .. admin_username)
            if not err and user_data then
                ngx.log(ngx.ERR, "WORKER INIT: Existing user data count: " .. #user_data)
                for i = 1, #user_data, 2 do
                    if user_data[i] and user_data[i+1] then
                        ngx.log(ngx.ERR, "WORKER INIT: " .. user_data[i] .. " = " .. user_data[i+1])
                    end
                end
            end
            
            red:close()
            ngx.log(ngx.ERR, "=== INIT_WORKER_BY_LUA_BLOCK END (USER EXISTS) ===")
            return
        end
        
        ngx.log(ngx.ERR, "WORKER INIT: Admin user does not exist, creating...")
        
        -- Create admin user
        local timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ")
        ngx.log(ngx.ERR, "WORKER INIT: Generated timestamp: " .. timestamp)
        
        ngx.log(ngx.ERR, "WORKER INIT: Executing HMSET with parameters:")
        ngx.log(ngx.ERR, "WORKER INIT: Key: user:" .. admin_username)
        ngx.log(ngx.ERR, "WORKER INIT: id = " .. admin_user_id)
        ngx.log(ngx.ERR, "WORKER INIT: username = " .. admin_username)
        ngx.log(ngx.ERR, "WORKER INIT: password_hash = " .. admin_password)
        ngx.log(ngx.ERR, "WORKER INIT: is_admin = true")
        ngx.log(ngx.ERR, "WORKER INIT: is_approved = true")
        ngx.log(ngx.ERR, "WORKER INIT: created_at = " .. timestamp)
        
        local ok, err = red:hmset("user:" .. admin_username,
            "id", admin_user_id,
            "username", admin_username,
            "password_hash", admin_password,
            "is_admin", "true",
            "is_approved", "true",
            "created_at", timestamp
        )
        
        if not ok then
            ngx.log(ngx.ERR, "WORKER INIT: Failed to create admin user: " .. (err or "unknown"))
            red:close()
            ngx.log(ngx.ERR, "=== INIT_WORKER_BY_LUA_BLOCK END (HMSET ERROR) ===")
            return
        end
        
        ngx.log(ngx.ERR, "WORKER INIT: HMSET successful, result: " .. tostring(ok))
        
        -- Verify creation
        local verify_exists, err = red:exists("user:" .. admin_username)
        if err then
            ngx.log(ngx.ERR, "WORKER INIT: Error verifying user creation: " .. err)
        else
            ngx.log(ngx.ERR, "WORKER INIT: User exists after creation: " .. tostring(verify_exists))
        end
        
        -- Get created data for verification
        local created_data, err = red:hgetall("user:" .. admin_username)
        if not err and created_data then
            ngx.log(ngx.ERR, "WORKER INIT: Created user data count: " .. #created_data)
            for i = 1, #created_data, 2 do
                if created_data[i] and created_data[i+1] then
                    ngx.log(ngx.ERR, "WORKER INIT: Created " .. created_data[i] .. " = " .. created_data[i+1])
                end
            end
        else
            ngx.log(ngx.ERR, "WORKER INIT: Error fetching created data: " .. (err or "unknown"))
        end
        
        red:close()
        ngx.log(ngx.ERR, "WORKER INIT: Admin user creation completed successfully")
        ngx.log(ngx.ERR, "=== INIT_WORKER_BY_LUA_BLOCK END (SUCCESS) ===")
    }

    # Shared memory zones
    lua_shared_dict config 1m;
    lua_shared_dict users 10m;

    # Upstreams
    upstream redis_backend {
        server redis:6379;
        keepalive 10;
    }

    upstream ollama_backend {
        server ollama:11434;
        keepalive 8;
    }

    # Redis connection settings
    redis2_connect_timeout 1s;
    redis2_send_timeout 1s;
    redis2_read_timeout 1s;

    server {
        listen 80;
        server_name localhost;

        root /usr/local/openresty/nginx/html;
        index index.html;
        
        # ===== DEBUG ENDPOINTS =====
        
        # Manual admin user creation endpoint
        location = /debug/create-admin {
            content_by_lua_file /usr/local/openresty/nginx/lua/init.lua;
        }
        
        # Redis debug endpoint
        location = /debug/redis {
            content_by_lua_block {
                local redis = require "resty.redis"
                local cjson = require "cjson"
                
                local red = redis:new()
                red:set_timeouts(1000, 1000, 1000)
                
                local ok, err = red:connect("redis", 6379)
                if not ok then
                    ngx.say('{"error": "Failed to connect to Redis: ' .. (err or 'unknown') .. '"}')
                    return
                end
                
                local res, err = red:ping()
                if not res then
                    ngx.say('{"error": "Failed to ping Redis: ' .. (err or 'unknown') .. '"}')
                    red:close()
                    return
                end
                
                -- Check admin user
                local admin_username = os.getenv("ADMIN_USERNAME") or "admin1"
                local user_data, err = red:hgetall("user:" .. admin_username)
                if err then
                    ngx.say('{"error": "Failed to get user data: ' .. err .. '"}')
                    red:close()
                    return
                end
                
                -- Check all user keys
                local all_keys, err = red:keys("user:*")
                if err then
                    all_keys = {}
                end
                
                red:close()
                
                ngx.say(cjson.encode({
                    redis_ping = "OK",
                    admin_username = admin_username,
                    user_exists = #user_data > 0,
                    user_data = user_data,
                    all_user_keys = all_keys,
                    timestamp = ngx.utctime()
                }))
            }
        }
        
        # Environment variables debug
        location = /debug/env {
            content_by_lua_block {
                local cjson = require "cjson"
                
                ngx.say(cjson.encode({
                    ADMIN_USERNAME = os.getenv("ADMIN_USERNAME"),
                    ADMIN_PASSWORD = os.getenv("ADMIN_PASSWORD"),
                    ADMIN_USER_ID = os.getenv("ADMIN_USER_ID"),
                    shared_admin_username = ngx.shared.config:get("admin_username"),
                    shared_admin_password = ngx.shared.config:get("admin_password"),
                    shared_admin_user_id = ngx.shared.config:get("admin_user_id"),
                    worker_id = ngx.worker.id(),
                    timestamp = ngx.utctime()
                }))
            }
        }

        # Internal Redis operations - simplified for debugging
        location ~ ^/redis-internal/hgetall/(.+) {
            internal;
            redis2_query hgetall $1;
            redis2_pass redis_backend;
        }

        location ~ ^/redis-internal/exists/(.+) {
            internal;
            redis2_query exists $1;
            redis2_pass redis_backend;
        }

        location ~ ^/redis-internal/hmset/(.+) {
            internal;
            set_by_lua_block $redis_cmd {
                local key_and_args = ngx.var[1]
                local parts = {}
                for part in key_and_args:gmatch("[^/]+") do
                    table.insert(parts, part)
                end
                
                local cmd = "hmset"
                for i, part in ipairs(parts) do
                    cmd = cmd .. " " .. part
                end
                return cmd
            }
            redis2_raw_query $redis_cmd;
            redis2_pass redis_backend;
        }

        # Generic redis2 fallback
        location ~ ^/redis-internal/(.+) {
            internal;
            redis2_raw_query $1;
            redis2_pass redis_backend;
        }

        # ===== AUTH ENDPOINTS =====
        
        location = /api/auth/login {
            content_by_lua_file /usr/local/openresty/nginx/lua/auth.lua;
        }

        location = /api/auth/register {
            content_by_lua_file /usr/local/openresty/nginx/lua/auth.lua;
        }

        location = /api/auth/verify {
            content_by_lua_file /usr/local/openresty/nginx/lua/auth.lua;
        }

        location = /health {
            content_by_lua_block {
                ngx.say('{"status": "healthy", "timestamp": "' .. ngx.utctime() .. '"}')
            }
        }

        # Static HTML page pretty routes
        location = / {
            try_files /index.html =404;
        }

        location = /login {
            try_files /login.html =404;
        }

        location = /register {
            try_files /register.html =404;
        }

        location = /chat {
            try_files /chat.html =404;
        }

        location = /admin {
            try_files /admin.html =404;
        }

        # Generic static fallback
        location / {
            try_files $uri $uri/ =404;
        }

        # Error pages
        error_page 404 /404.html;
        error_page 500 502 503 504 /50x.html;
    }
}